<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java常见核心命题</title>
      <link href="posts/javaInit.html"/>
      <url>posts/javaInit.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java常见核心命题"><a href="#Java常见核心命题" class="headerlink" title="Java常见核心命题"></a>Java常见核心命题</h1><h2 id="本章思维导图"><a href="#本章思维导图" class="headerlink" title="本章思维导图"></a>本章思维导图</h2><p><img src="/posts/javaInit/img1.png" alt="思维导图"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol><li><p><strong>抽象与接口</strong></p><ul><li>抽象是对类的抽象，为了解决代码复用，表示is-a的关系。是一种自下而上的设计思路，先有子类的代码重复，才有抽象上层父类；</li><li>接口是对行为的抽象，侧重于解耦，实现了约定和实现的分离，表示has-a的关系。是一种自上而下的设计思路，先设计好接口，再考虑具体实现。</li></ul></li><li><p><strong><code>final</code>关键字</strong></p><ul><li>final修饰变量：不可被修改</li><li>final修饰参数：在函数里不可被修改</li><li>final修饰方法：不可被重写（private级别的方法默认都是final）</li><li>final修饰类：不可被继承</li><li><strong>final修饰对象类型变量</strong>，仅引用不可变</li></ul></li><li><p><strong><code>static</code>关键字</strong></p><ul><li>静态变量：类变量（属于类而非属于实例），所有实例共享，在内存中只有一份，会在类初始化的时候赋系统默认值（final修饰的除外）。<strong>基本类型</strong>会将值存储在方法区，而<strong>引用类型</strong>在方法区存储的是引用/堆地址</li><li>静态方法：必须有实现，不可为抽象方法。</li><li>静态代码块：仅类初始化运行一次，先父后子。</li><li>静态内部类：<ul><li>在外部类的非静态方法中，使用方式没有差别</li><li>在外部类的静态方法以及在其他类中，如果要使用，非静态内部类需要new Outter().new Inner();来实现，而静态内部类只需new Inner()即可。故，内部类都写成静态的</li></ul></li><li>静态导包：静态方法或者变量的使用方式是Class.method/var，采用静态导包之后，可以直接使用method而不必指明Class</li></ul></li><li><p><strong>泛型</strong></p><ul><li>概念：参数化类型（区别于参数化变量）；仅在编译阶段有效，编译时的类型安全检测机制；运行期泛型消失（类型擦除）</li><li>分类：泛型类 &amp; 泛型接口 &amp; 泛型方法</li><li>类型通配符：<ul><li><code>&lt;?&gt;</code>无界通配符</li><li><code>? extends Type</code> 上边界通配符，只读不写，如list只能get而不能add()</li><li><code>? super Type</code> 下边界通配符，只写不读，如list只能返回Object，作为函数返回类型没有意义</li><li>通配符限定的范围是在确定”<strong>参数化类型</strong>“的时候</li></ul></li></ul></li><li><p><strong>缓存池</strong></p><ul><li><p>基本类型缓存池，如果对应包装类型的数值范围在缓存池内，直接使用缓存池中的对象</p><ul><li><p>Code Demo: </p></li><li><p>```java<br>Integer a = 123; // Integer.valueOf(123)<br>Integer b = 123;<br>System.out.println(a == b); // true<br>Integer a = new Integer(123);<br>Integer b = new Integer(123);<br>System.out.println(a == b); // false<br>Integer a = 129;<br>Integer b = 129;<br>System.out.println(a == b); // false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">       Integer&#x2F;short的范围为-128～127</span><br><span class="line">     </span><br><span class="line">   * String类型缓存池，保存所以String字面量，同时还可以inter()进行添加</span><br><span class="line"></span><br><span class="line">     * inter(): 添加进String pool中返回该字符串的引用</span><br><span class="line"></span><br><span class="line">## HashMap</span><br><span class="line"></span><br><span class="line">较为详细的核心原理请参考[徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样](https:&#x2F;&#x2F;yzhao.top&#x2F;posts&#x2F;myHashMap.html)</span><br><span class="line"></span><br><span class="line">* 数据结构：数组（桶）+链表（拉链法）</span><br><span class="line"></span><br><span class="line">* hash计算公式以及优势：</span><br><span class="line">  * 借助Object类的hashCode()</span><br><span class="line">  * &#96;&#96;&#96;h&#x3D;h^(h&gt;&gt;&gt;16)&#96;&#96;&#96; 这里的改进就是高16位与低16位异或，主要优化低16位相等时的哈希值，减少哈希冲突</span><br><span class="line">  * **寻址算法**：&#96;&#96;&#96;n&#x3D;(n-1)&amp;h&#96;&#96;&#96;本质是对n求模，即&#96;&#96;&#96;h%n&#x3D;h&amp;(n-1)&#96;&#96;&#96;，尤其是当n为2的n次幂时寻址更加均匀，所以默认的HashMap的长度为&#96;&#96;&#96;1&lt;&lt;&lt;4&#96;&#96;&#96;</span><br><span class="line">  </span><br><span class="line">* 加载因子为什么设置为0.75？过大哈希冲突的概率增加；过小则浪费空间，频繁扩容</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;V put(K key, V value)&#96;&#96;&#96; 新增KV对流程：</span><br><span class="line">  * hash算法：得到桶下标，即&#96;&#96;&#96;i &#x3D; (n-1)&amp;h&#96;&#96;&#96;</span><br><span class="line">  * 若桶数组为空，扩容</span><br><span class="line">  * 若当前桶下标为空，newNode，即&#96;&#96;&#96;tab[i]&#x3D;new Node&lt;&gt;(hash, key, value, next)&#96;&#96;&#96;</span><br><span class="line">  * 若当前桶下标有值，即**哈希冲突**，采用拉链法解决</span><br><span class="line">    * 创建临时节点e</span><br><span class="line">    * 若&#96;&#96;&#96;p.hash &#x3D;&#x3D; q.hash &amp;&amp; p.key &#x3D;&#x3D; q.key &amp;&amp; p.key.equals(q.key) &#x3D;&gt; e &#x3D; p&#96;&#96;&#96;</span><br><span class="line">    * 若是红黑树，则使用红黑树的方式新增</span><br><span class="line">    * 若是链表</span><br><span class="line">      * 遍历结束，证明是新增节点，所在尾端新增node</span><br><span class="line">      * 如果在循环过程中发现有相同的key的时候，证明是覆盖节点，此时该节点为e，结束循环；</span><br><span class="line">    * 最后，对相同的key，如果运行覆盖value，则此时进行value值覆盖，并返回oldvalue</span><br><span class="line">  * 若当前HashMap的&#96;&#96;&#96;size&gt;threshold&#96;&#96;&#96;（首次扩容&#x3D;0.75*16&#x3D;12）时，扩容</span><br><span class="line"></span><br><span class="line">  具体新增流程为：</span><br><span class="line"></span><br><span class="line">  ![HashMap之put方法](javaInit&#x2F;img2.png)</span><br><span class="line"></span><br><span class="line">* &#96;&#96;&#96;Node&lt;K, V&gt;[] resize()&#96;&#96;&#96; 扩容</span><br><span class="line">  * 记录现有的capacity以及现有的Threshold</span><br><span class="line">  * 不可超过最大MAXMUM_CAPACITY且扩容为现在的2倍</span><br><span class="line">  * 若链表长度为1，直接赋值</span><br><span class="line">  * 若该节点是红黑树，则进行相关操作</span><br><span class="line">  * 若链表不为1，进行**链表复制**，JDK1.8优化：</span><br><span class="line">    * 若e.hash &amp; oldCap &#x3D;&#x3D; 0，还是用原索引，放在原来的桶里</span><br><span class="line">    * 若e.hash &amp; oldCap &#x3D;&#x3D; 1，放在新的桶里，新的索引&#x3D;原索引+oldCap</span><br><span class="line">  * **优化点**：在进行链表复制的时候，通过e.hash &amp; oldCap 的结果来判断新的索引地址</span><br><span class="line">  </span><br><span class="line">* &#96;&#96;&#96;V get(Object key)&#96;&#96;&#96; 查找</span><br><span class="line"></span><br><span class="line">  * 计算key的hash值，以及桶下标</span><br><span class="line">  * 若链表的第一个节点的key就是目标key，则返回该节点(e.val)</span><br><span class="line">  * 否则，进行循环遍历判断key是否是目标key</span><br><span class="line">  * 若某一个节点位红黑树节点，则使用红黑树的方式遍历</span><br><span class="line"></span><br><span class="line">* **并发场景梳理**</span><br><span class="line"></span><br><span class="line">  * HashMap是非线程安全的，不保证线程获取数据的一致性</span><br><span class="line">  * 链表成环问题（JDK1.8已经修复）:</span><br><span class="line">    * 扩容流程：&#96;&#96;&#96;next&#x3D;e.next -&gt; tab[i]&#x3D;e -&gt; e &#x3D; next&#96;&#96;&#96;</span><br><span class="line">    * **风险点**：这里采用的是头插法插入节点，会改变链表原来节点的顺序；</span><br><span class="line"></span><br><span class="line">  ![JDK1.7链表成环核心原因分析图示](javaInit\img3.png)</span><br><span class="line"></span><br><span class="line">注意：HashMap依旧是线程不安全的，所产生的线程问题无非就是同一份数据被不同的线程所改变造成的（**即原子性被打断**）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 并发</span><br><span class="line"></span><br><span class="line">### ConcurrentHashMap</span><br><span class="line"></span><br><span class="line">**核心**：CAS + synchronized</span><br><span class="line"></span><br><span class="line">Node&lt;K,V&gt; table采用了**volatile**来修饰</span><br><span class="line"></span><br><span class="line">hash函数的小改进：(h^(h&gt;&gt;&gt;16))&amp;HASH_BITS HASH_BITS主要是为了消除符号位置，即MAX_VALUE;因为在ConcurrentHashMap中的hash需要表示正在转移(-1)、转移成树(-2)以及保留值(-3)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;V put(K key, V value) &#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">- 数组为空，初始化；</span><br><span class="line">- 若当前槽点没有值，CAS创建节点，失败自旋（for循环）</span><br><span class="line">- 若槽点有值，判断当前槽点是不是MOVED节点，如果是，会参与扩容</span><br><span class="line">- 若槽点有值且扩容完成，锁定当前槽，链表尾插</span><br><span class="line">- 线程安全的手段：</span><br><span class="line"></span><br><span class="line">- - 数组初始化通过自旋+CAS+double check保证初始化成功 initTable()</span><br><span class="line">  - 新增节点时：</span><br><span class="line"></span><br><span class="line">- - - 自旋确保一定可以成功；</span><br><span class="line">    - 槽点为空时，通过CAS新增，如果失败，则自旋；</span><br><span class="line">    - 槽点有值，锁槽点</span><br><span class="line">    - 红黑树旋转时，锁root</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#96;&#96;&#96;</span><br><span class="line"></span><br><span class="line">- 拷贝数组时从尾部开始；</span><br><span class="line">- 拷贝槽点，锁原数组槽点，拷贝完成时，原数组槽点赋值为ForwardingNode</span><br><span class="line">- 此时如果有put到此槽点时，发现时MOVED会参与增加线程帮助扩容</span><br><span class="line"></span><br><span class="line">### synchronized</span><br><span class="line"></span><br><span class="line">- 原理：无锁 --&gt; 偏向锁 --&gt; 轻量级锁 --&gt; 重量级锁</span><br><span class="line">- 使用方式：</span><br><span class="line"></span><br><span class="line">- - **类锁**：类共有的，不同的实例也会被锁住；除此之外，还有String的字面量赋值以及基本数据类型的包装类型在缓存池范围内的情况下</span><br><span class="line">  - **对象锁**：实例共有，同一个实例才会被锁住</span><br><span class="line"></span><br><span class="line">### 线程状态</span><br><span class="line"></span><br><span class="line">- 新建状态new，线程创建但未启动</span><br><span class="line">- 就绪状态runnable，调用start()</span><br><span class="line">- 运行状态running，获得CPU执行时间片</span><br><span class="line">- 阻塞状态blocked，同步阻塞；主动阻塞；被动阻塞</span><br><span class="line">- 终止状态dead</span><br><span class="line"></span><br><span class="line">### Java创建线程方法</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;class A extends Thread&#123;&#125;&#96;&#96;&#96; 继承Thread类，并重写run()方法；</span><br><span class="line">- &#96;&#96;&#96;class B implements Runnable&#96;&#96;&#96;实现Runnable接口，作为Thread参数</span><br><span class="line">- &#96;&#96;&#96;class C implements Callable&lt;T&gt;&#96;&#96;&#96;实现Callable接口，作为Future的参数，Future再作为Thread的参数，可接受返回值</span><br><span class="line"></span><br><span class="line">代码示例：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;&#x2F;1 class A extends Thread</span><br><span class="line">new A().start();</span><br><span class="line">&#x2F;&#x2F;2 runnable</span><br><span class="line">new Thread(()-&gt;&#123;....&#125;).start(); &#x2F;&#x2F; 用lambda表达式来实现runnable</span><br><span class="line">&#x2F;&#x2F;3 callable</span><br><span class="line">Future&lt;Integer&gt; future &#x3D; new Future&lt;&gt;(()-&gt;&#123;....&#125;); &#x2F;&#x2F; 用lambda来实现callable</span><br><span class="line">new Thread(future).start();</span><br><span class="line">System.out.println(future.get()); &#x2F;&#x2F; 获得返回值</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>无论哪种方式，本质都是<code>new Thread()</code> 无非使用了不同的start方法</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li>当该线程执行完某一项功能之后，可以调用this.notify() or this.notifyAll()方法来唤醒所有阻塞的线程，再使用this.wait()是自己进入阻塞状态<ul><li>注意：一定要先唤醒，否则一旦自己陷入阻塞状态的时候，是不会释放锁的</li></ul></li></ul><p>交替打印奇偶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span> != <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadTest::printOdd, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadTest::printEven, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了原始的notify与wait方法，J.U.C还提供其他好用的同步工具</p><ul><li>CountDownLatch，当计数器为0时，在CountDownLatch上await的线程会被唤醒；适用于等待所有子线程全部完成之后再做操作的场景，可以类比join</li><li>CycliBarrier，等待所有线程到达统一状态，再进行全部同时执行<ul><li>使用await进行阻塞，等待所有线程都执行到await之后，再同时执行后续操作；而且支持可重复使用</li><li><code>new CycliBarrier(nums)</code> 表示能控制几个线程，大于这个数目的线程不受CycliBarrier控制</li></ul></li><li>Semaphore，前两个是内部维护一个状态码，判断是否为0，而信号量是增加的机制<ul><li><code>semaphore.release()</code> 使得信号量+1；</li><li><code>semaphore.acquire(nums)</code>阻塞，等待信号量累加到nums的值，才进行执行代码</li></ul></li><li>Condition,需要Lock来通过newCondition()进行调用<ul><li><code>condition.signalAl()</code></li><li><code>condition.await()</code></li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h3 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h3><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS: AbstracQueuedSynchronizer抽象同步队列</p><p><strong>基本场景</strong>：加锁；释放锁；等待；唤醒</p><p><strong>state状态维护</strong>：</p><ul><li>volatie修饰，保证内存可见性</li><li>getState以及setState禁止子类重写</li><li>compareAndSetState()采用乐观锁CAS</li></ul><p><strong>CLH队列</strong>（FIFO的双向队列）</p><ul><li>当前线程获取state失败，AQS会构建节点加入CLH同步队列中，阻塞该线程；</li><li>当同步状态释放时，会把首节点唤醒（公平锁），使其尝试获取同步状态</li></ul><p><strong>Condition通知机制，维护了等待队列</strong></p><ul><li>调用了await()方法的线程，加入到Condition等待队列，同时唤醒CLH队列的下一个节点；</li><li>线程中调用了signal()方法后，Condition等待队列的首位等待任务会被加入CLH队列中，等待被唤醒</li><li>当线程调用unLock()方法后，CLH队列下一个节点会被唤醒</li></ul><p>独占和共享模式</p><p>自定义同步器。摘抄自《Java并发编程之美》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueueSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 锁是否被持有 1被持有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> arg == <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> arg==<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(getState==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4 返回Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock</strong></p><ul><li>lock.lock()</li><li>lock.unlock()</li><li>lock.newConditoin()</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe：</p><ul><li>compareAndSwapObject</li><li>compareAndSwapInt</li><li>compareAndSwapLong</li><li>…</li></ul><p>AtomicXXX</p><p>CAS是Java Unsafe类中实现的操作，是native方法，其是一种<strong>无锁的编程手段</strong>，全称是 Compare And Set。CAS(V,A,B) 将V上的值与A做比较，如果相等，则更新为B;否则，禁止更新，返回V的值</p><p>CAS的核心问题</p><ul><li>ABA问题：所谓ABA问题，指的是一个值由A变成了B，又变成了A，我此时使用CAS去赋值的时候，认为没有变化，则会进行赋值，但是实际上已经变化了。解决方案就是增加版本号</li><li>ABA主要的例子：如果一个链表的A.next被修改过，虽然A还是A，但是其实最终的结果和我们想要的不一样</li><li>循环时间长，开销大</li><li>只能保证一个共享变量的原子操作</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>原理</strong>：静态内部类维护了ThreadLocalMap，维护了实例(V)与ThreadLocal(K)的映射；其中，key是弱引用，但是value是强引用，依旧会出现内存泄露的问题</p><p>场景：</p><ul><li>ThreadLocal不能解决线程间数据共享的问题（因为其只是线程本地变量）</li><li>ThreadLocal隐式的在不同线程创建独立实例副本避免线程安全</li><li>ThreadLocalMap维护了ThreadLocal(与线程挂钩)与Object的映射</li><li>ThreadLocal适用于变量在线程间隔离且在方法间共享的场景</li></ul><h3 id="J-U-C相关工具"><a href="#J-U-C相关工具" class="headerlink" title="J.U.C相关工具"></a>J.U.C相关工具</h3><p>CompletableFuture，是属于ForkJoin的实现</p><ul><li>异步提交任务的方法supplyAsync()或者是runAsync() 前者接受返回值，后者没有返回值</li><li>有其他来进行多个任务串联进行的方式，如thenApply()等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 八股战神系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样</title>
      <link href="posts/myHashMap.html"/>
      <url>posts/myHashMap.html</url>
      
        <content type="html"><![CDATA[<h1 id="徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样"><a href="#徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样" class="headerlink" title="徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样"></a>徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>反思我们在项目中，或者生活中，遇到的最多的一个结构，应用最为频繁的一个结构，应该是什么？</p><p>数组？链表？树？图？</p><p>如果，让我来选择一个皇冠，我愿意将它戴在散列表的头上。</p><p>散列表，就是我们熟知的Map。我们想象一下的他的结构，键值对的结构，在现在的代码社会里几乎无所不在，万物皆对象，对象就是变量名与值的对应，不同的是，对象的Key我们一般事先定义好。亦或者，现在极其普遍的Json结构，其本质也是键值对的结构。</p><p>那么，我们为什么会需要这样一个结构呢？</p><p>众所周知，数组是程序世界的基石。我甚至都不愿意把皇冠给它，因为它乃基石。数组的一大特点是连续内存存储，所以他有一个优势，即按照下标，我们读取一个数值的时间复杂度是o(1)。</p><p>但是数组有一个前提，按照下标。</p><p>可不可以有一个不需要固定下标，也可以实现随机o(1)复杂度的访问的数据结构？</p><p>当然有，这就是我们的重点——键值对，即我们需要一个维护key以及该key所对应的value的一个键值对的数据结构。</p><h2 id="自制HashMap"><a href="#自制HashMap" class="headerlink" title="自制HashMap"></a>自制HashMap</h2><h3 id="弄清需求，搭建框架"><a href="#弄清需求，搭建框架" class="headerlink" title="弄清需求，搭建框架"></a>弄清需求，搭建框架</h3><p>在我个人浅薄的知识面下，我的第一反应是，键值对作为一个对象，因为我要存储一堆键值对，那么，很自然的会写出如下的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node[] kvArr = <span class="keyword">new</span> Node[size];  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但，</p><p>我么假如使用上述结构，那么，我们如何实现根据K获得V这一功能呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node node:kvArr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.k.equals(key)))&#123;</span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个什么鬼的数据结构 </p><p>所以大家可以明白了，底层使用的数组，却得到了更差劲儿的性能？</p><p>那么我们可不可以优化增加的逻辑，使得Node不是随便加？</p><h3 id="测试逻辑，完善框架"><a href="#测试逻辑，完善框架" class="headerlink" title="测试逻辑，完善框架"></a>测试逻辑，完善框架</h3><p>要明白的一点，要想使得查询不遍历，那么增加也不得随意，必须按照一定的规则</p><p>什么规则？</p><p>最简单的角度，我是不是可以把k与下标做一个函数关联？</p><p>比如，经过计算，<code>f(k) = i</code> 的放在下标<code>i</code>的位置里</p><p>那么，我们可以增加一个如上函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key.hashCode() % capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要解释两个东西</p><ul><li>hashCode(). hashCode是Object类的基本属性，用来对每一个对象计算一个数值</li><li>capacity。我们最终得到的数值是需要放在长度为capacity的数组中的，所以需要取余，以免越界。至于capacity的取值，这里先xjb等于10</li></ul><p>所以，无论是增加还是查询，都需要借助该hash函数，所以，灵魂是谁，一目了然</p><p>增加功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    kvArr[hash(key)] = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kvArr[hash(key)].getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得很完美</p><p>不</p><p>现在，才刚刚入门</p><p>这个所谓的优化，有两个极其大的漏洞</p><ol><li><p>size如果一旦确定。用尽了怎么办？</p></li><li><p>hash值，相等怎么办</p></li></ol><h3 id="深入优化，完成框架"><a href="#深入优化，完成框架" class="headerlink" title="深入优化，完成框架"></a>深入优化，完成框架</h3><p>所以，我们遇到了hash结构的第一个核心问题，那就是hash冲突</p><p>如何解决hash冲突呢？</p><p>很简单的方式，在add函数里增加判断，如果计算该hash值所在数组有值，则增加到下一个位置，如果还有值，继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//循环判断是否有值</span></span><br><span class="line">    <span class="keyword">while</span> (kvArr[hash] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    kvArr[hash] = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!!!</p><p>当我们修改add函数的同时，不要忘记了，查询和新增永远是相辅相成的。</p><p>那么我们查询也需要依赖冲突算法，那么我们该如何解决？</p><p>这里有一个直接的想法，就是如果在add的时候，解决了几次冲突，我们可以记录下来冲突的次数就好了？</p><p>这里我脑子里出现的第一个思路是：记录下来次数，当我get的时候按照既定次数去计算即可。</p><p>但，次数记载哪里？</p><p>我们在add的时候，解决冲突的次数是不确定的，他是一个随机往后寻找位置的一个过程。而我们在查找的时候，只有一个key以及根据这个key第一次hash计算出来的Node的节点。</p><p>那么，记录次数似乎不可以，我们还有什么？</p><p>我们有key以及node节点的key啊！</p><p>key的值一样不就可以了？！！！</p><p>所以，代码就简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (!kvArr[hash].getKey().equals(key)) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kvArr[hash].getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明的小伙伴，我猜你一定知道了些什么。</p><p>是的，这就是大名鼎鼎的<strong>散列表之线性探测法</strong></p><h3 id="最终结果，落地可用"><a href="#最终结果，落地可用" class="headerlink" title="最终结果，落地可用"></a>最终结果，落地可用</h3><p>上述解决了我们的一个核心问题，那就是hash冲突，实际上这属于hash函数的设计范畴。</p><p>还有另外一个核心问题，我们的初始化size用尽了，怎么办？</p><p>扩容呀</p><p>在扩容的时候，我们在这里需要提前明确两个概念：</p><ul><li>size. size指的是当前Map中已经有KV对的数量</li><li>capacity. capacity的含义是，目前Map可以承载的最大KV对的数量</li></ul><p>明确了这两个概念之后，所谓扩容，指的是，当size==capacity的时候或者说逼近，扩大capacity的容量</p><p>那这里需要首先提供，size的计算方法，在每次执行put的时候，相当于size加了一。</p><p>所以，Map的增加函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == capacity) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (kvArr[hash] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    kvArr[hash] = node;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了什么时候调用resize函数之后，我们接下来要做的是，集中精力编写resize函数。我们先来搞清楚几个关键点：</p><ul><li>capacity需要扩大多少？</li><li>原来的数据如何放到扩容后的数组中？</li></ul><p>针对第一个问题，我们就简单的扩容2倍</p><p>对于第二个问题，我相信很多人的直接就是纯碎的拷贝。但实际上，我们如果能重新计算Hash，重新改变位置，才是更合适的。这里的问题就是，更好的解决hash冲突问题。其实hash的关键问题，就是如何巧妙的额设计，避免hash冲突。因为，hash冲突之后，按照线性探测的方法，我们需要更多的循环，这会严重影响HashMap的性能</p><p>所以，我们设计的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tmp = <span class="keyword">new</span> Node[<span class="keyword">this</span>.capacity];</span><br><span class="line">    System.arraycopy(kvArr, <span class="number">0</span>, tmp, <span class="number">0</span>, tmp.length);</span><br><span class="line">    <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.capacity * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.kvArr = <span class="keyword">new</span> Node[<span class="keyword">this</span>.capacity];</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; node:tmp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.put(node.getKey(), node.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我的思路是，先把当前的数组<strong>浅拷贝</strong>一份，然后用扩容后的数组替换掉当前的数组，此时，该数据capacity为之前的2倍，<strong>size为0</strong></p><p>这就是扩容。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>目前为止，原则上我们的自制HashMap已经全部完成。 简单总结一下几个核心：</p><ul><li><strong>hash函数</strong>。<strong>解决key与下标相关联的问题</strong>。在这里，我们采用的是Object自身的hascode来和capacity进行取余来计算。hashcode可以基本保证一个独有的值，取余只是为了让hashcode可以放置在数组之中</li><li><strong>Node[]对象数组</strong>。<strong>解决如何存储的问题</strong>。在这里，我们底层采用的是对象<strong>数组</strong>，我们将KV封装为一个节点对象，这是为了KV的一体性</li><li><strong>Hash冲突</strong>。<strong>解决当两个key的hash值一样如何解决的问题</strong>。在这里，使用的是<strong>线性探测法</strong></li><li><strong>扩容。解决当capacity不够用的问题。</strong>扩容的核心是需要定义清楚size与capacity的含义</li></ul><p><strong>如下表1，是HashMap与MyHashMap的对标：</strong></p><table><thead><tr><th align="left"></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td align="left">HashMap</td><td><strong>39ms</strong></td><td><strong>11ms</strong></td></tr><tr><td align="left">MyHashMap -（数组+ 线性探测）</td><td><strong>1068ms</strong></td><td><strong>113ms</strong></td></tr></tbody></table><p>在这里，有一个小小的插曲，我在进行大容量测试的时候，出现了一个数组越界的异常，日志显示我有一个负数的下标。</p><p>？？？</p><p>经排查，hashcode是有可能为负数的，其根本原因是hashcode的算法要不停的相乘然后累加，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from JDK String.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的根本原因是因为，int的范围在-2^31 ~ 2^31 - 1 即[-2147483648, 2147483647]</p><p>截止到此，我们的整个的Map就开发完毕了。</p><p><strong>但，我们的put性能慢了26倍，get性能慢10倍</strong></p><h2 id="自制HashMap的性能追逐"><a href="#自制HashMap的性能追逐" class="headerlink" title="自制HashMap的性能追逐"></a>自制HashMap的性能追逐</h2><p>首先，可以进行改进的地点有哪些？</p><p>哈哈哈，当然是核心要点那里：hash函数、冲突方法、底层存储以及扩容结构</p><h3 id="hash函数的探索"><a href="#hash函数的探索" class="headerlink" title="hash函数的探索"></a><strong>hash函数的探索</strong></h3><p>先开始一些专业点的东西，什么叫做Hash函数</p><p><strong>定义</strong>：hash function 又称散列函数、哈希函数，指的是，将任意长度的数据映射到有限长度的域上。映射后的值称为哈希值。</p><p><strong>性质</strong>：</p><p>​        1. 如果两个哈希值不同，那么原始输入一定不同；但哈希值相同，原始输入不一定相同，这种情况称之为“哈希碰撞”。一个好的hash函数的设计很少出现哈希碰撞。</p><p>​        2. 哈希值就有不可逆性，没有办法用来逆向计算原来的数值。其根本原因在于性质1，同一个hash值对应的输入有很多。</p><p><strong>应用</strong>：保护资料，如SHA-256；确保传递真实的信息；散列表；错误校正，如冗余校验；语音识别，如MD5；</p><p>这里，我们采用Java 8中的Hash函数来进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个依旧借助了hashCode来计算hash值，即 h^(h&gt;&gt;&gt;16)</p><p>其中，&gt;&gt;&gt;  表示的是无符号右移，即，忽略符号为，空位都已0补齐。</p><p>举例，如10的二进制为1010，那么10 &gt;&gt;&gt; 2 指的是右移2位，即，0010 = 2 </p><p>之后，在使用的时候，需要进一步和当前capacity进行求 <strong>与</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (capacity - <span class="number">1</span>) &amp; hash(key);</span><br></pre></td></tr></table></figure><p>PS： 这里在测试get10万次的时候，才测试出来一个bug。当前的put的逻辑，先计算了hash值，再进行扩容，扩容之后整个hash函数已经打散了。但是，最终put到数组中的还是按照原来的Hash值去进行的。这样在进行get的时候，初始计算的Hash值不同，再进行进行线性探测的时候，轨迹完全不同，所以就会出现null的情况。</p><p>但令人痴迷的是，10万次仅有一次这种情况。</p><p>这次的比较结果，如表2所示：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>HashMap</td><td><strong>39ms</strong></td><td><strong>11ms</strong></td></tr><tr><td>MyHashMap -（数组+ 线性探测）</td><td><strong>1068ms</strong></td><td><strong>113ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + JDK8hash函数）</td><td><strong>25188ms</strong></td><td><strong>36445ms</strong></td></tr></tbody></table><p>怎么回事</p><p>我们明明改造了HashMap的hash函数，为什么性能更差呢？</p><p>这主要是因为我们的hash函数直接照抄jdk 却没有系统性的优化，比如，为什么hashCode要 右移16？我们这里的capacity=10，我们右移10是不是可以？</p><p>那么我们看看，这次的对比结果：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap -（数组+ 线性探测+右移10位+capacity=10）</td><td><strong>24936ms</strong></td><td><strong>24936ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=10）</td><td><strong>25188ms</strong></td><td><strong>36445ms</strong></td></tr></tbody></table><p>那，我们让capacity = 16呢？</p><p>神奇的事情发生了！！！！</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap -（数组+ 线性探测+右移10位+capacity=10）</td><td>24936ms</td><td>24936ms</td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=10）</td><td>25188ms</td><td>36445ms</td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移8位 + capacaity=8）</td><td><strong>935ms</strong></td><td><strong>116ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=16）</td><td><strong>710ms</strong></td><td><strong>76ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移32位 + capacaity=32）</td><td>41983ms</td><td>68684ms</td></tr><tr><td>MyHashMap -（数组+ 线性探测 + hashcode%capacity+ capacity=10）</td><td>1068ms</td><td>113ms</td></tr><tr><td>MyHashMap -（数组+ 线性探测 + hashcode%capacity+ capacity=16）</td><td>995ms</td><td>98ms</td></tr></tbody></table><p>从上述的对比，我们发现，适当的增加capacity能简单的提升性能，但单纯修改这个值，无济于事。</p><p><strong>当jdk的hash函数 配合 capacity = 16 可以极大的提升性能。</strong></p><p>这里的16，是一个非常有讲究的数据</p><p>好了，经过我们的借鉴，我们目前put性能慢了17倍，get性能慢了5倍</p><h3 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h3><p>我们当前使用的线性探测的方法，当冲突之后，效率及其低下。有没有其他更加优雅的冲突解决方法？</p><p>这里直接给一些解决方案的汇总，大致可以分为在散列表内解决的，称之为闭散列法，在散列表之外解决的，称之为开散列法，也称之为拉链法。</p><p>来了，我依旧借鉴 jdk 8的经典拉链法。</p><p>所谓拉链法，就是当hash冲突的时候，已当前的node节点为首位，不停往下扩展。所以，首先需要修改原始数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，就是链表的结构</p><p>然后，当put和get的时候按照新的冲突方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (<span class="keyword">this</span>.capacity - <span class="number">1</span>) &amp; hash(key);</span><br><span class="line">    Node&lt;K,V&gt; p = table[hash];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        table[hash] = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (<span class="keyword">this</span>.capacity - <span class="number">1</span>) &amp; hash(key);</span><br><span class="line">    Node&lt;K,V&gt; p = table[hash];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.getKey().equals(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p.getKey().equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造如此完美，而且，resize是不是不是必须的了？因为容量无穷无尽。当然了，经过接下来的测试，resize依旧需要，但他的作用变了。</p><p>第一波的测试：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10)</td><td>989ms</td><td>106ms</td></tr><tr><td>MyHashMap2-(数组 + 线性探测 + 右移16位 + capacaity=16)</td><td>681ms</td><td>66ms</td></tr><tr><td><strong>MyHashMap3-(数组 + 拉链法(无resize)+ 右移16位 + capacaity=16)</strong></td><td><strong>14387ms</strong></td><td><strong>20365ms</strong></td></tr><tr><td>HashMap(JDK 8)</td><td>31ms</td><td>10ms</td></tr></tbody></table><p>原因很简单，没有resize啊，太臃肿了，导致算完hash都需要循环遍历，这有违初衷o(1)啊</p><p>这里提出一个新的概念，我们如何衡量Hash函数的性能？这里需要首先计算平均查找长度（ASL），而ASL又依赖于装载因子，</p><p><strong>装载因子 = 填入表中的元素个数 / Hash表的长度</strong></p><p>性质：当装载因子越大，说明元素个数多，空闲位置少，冲突概率大，ASL就越大，性能下降。</p><p>所以，真正的扩容，应该在达到一定的装载因子时就要进行.</p><p>这里不再证明，选择JDK 8的装载因子 <strong>0.75</strong> 我们分别进行测试</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子为1)</td><td>1083ms</td><td>107ms</td></tr><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子为0.75)</td><td><strong>234ms</strong></td><td><strong>135ms</strong></td></tr></tbody></table><p>天啊，，，仅仅是修改一个扩容的条件而已，性能居然好到令人发指</p><p>ok, 我们接下来进行一个 完整的测试，同时针对拉链法进行扩容改造</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子0.75)</td><td>228ms</td><td>124ms</td></tr><tr><td>MyHashMap2-(数组 + 线性探测 + 右移16位 + capacaity=16++装载因子0.75)</td><td>124ms</td><td>15ms</td></tr><tr><td><strong>MyHashMap3-(数组 + 拉链法(有resize)+ 右移16位 + capacaity=16+装载因子0.75)</strong></td><td><strong>46ms</strong></td><td><strong>14ms</strong></td></tr><tr><td>HashMap(JDK 8)</td><td>31ms</td><td>10ms</td></tr></tbody></table><p>神奇的事情，终于发生了。</p><p>我们的性能追上来了</p><p><strong>我们的性能终于在10万量级追上了jdk1.8</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们对全文进行一个粗略的总结</p><ul><li>存储结构。<strong>底层是对象数组。</strong>对象用于标记KV对，数组用于将hash值与下标进行关联。</li><li>Hash函数。解决key与Hash值一一映射的关系。借助Object的HashCode进行计算，JDK 8采用 h^(h&gt;&gt;&gt;16)</li><li>初始容量。为了与Hash函数一致，初始容量为16。</li><li>装载因子。扩容有一个合适的时机，过早扩容，会因扩容影响性能；过晚扩容，则会增大Hash函数的冲突的概率，影响性能</li><li>Hash冲突。本文选择了拉链法与线性探测法，我们可以看到，在put的性能拉链法优于线性探测法，而get性能差距不大</li></ul><p>附录</p><ol><li>内部类的作用以及为什么需要静态内部类？</li><li>深拷贝与浅拷贝</li><li>hashCode与int的范围</li><li>jdk 1.8的初始容量与hash函数的设计</li><li>装载因子为0.75的数学含义</li><li>JDK 引入红黑树</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 徒手撸轮子系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次，上路</title>
      <link href="posts/origin.html"/>
      <url>posts/origin.html</url>
      
        <content type="html"><![CDATA[<h1 id="再一次，上路"><a href="#再一次，上路" class="headerlink" title="再一次，上路"></a>再一次，上路</h1><p>很早就想把自己的博客网站重新给搞起来，也不知道是真的没时间还是怎么的，一直拖到现在，也是因为很偶然的因素，想着推出一个自己的一个系列。</p><p>系列的内容就是，重复的造轮子，终极目的是能把所有的东西给造一遍。</p><p>呃。。。</p><p>你知道的，我开个玩笑。</p><p>类似的事情，我关注的亦或是我没关注的，有很多人在做了。我也没必要去对标，也没有特别的标新立异，甚至我还会参考、借鉴。毕竟，别人比我理论研究的更深、图解画的更详细、甚至于语言表达更好。</p><p>我自己只不过是经验尚浅的码农，在一点一点前进罢了。</p><p>废话不多说。</p><p>系列的名字就叫做——《徒手撸轮子系列》</p><p>大致分为几个部分：</p><ul><li>原生数据结构与算法对标，如：HashMap、Set、List、Sort、Thread等</li><li>基础框架，如：Spring、Spring Boot等</li><li>基础通信组件，如：Thrift、Netty等</li><li>基础存储设施，如：MySQL、Redis等</li><li>基础消息队列，如：Kafka等</li><li>……</li></ul><p>当然，我会逐步增加。</p><p>基本节奏大致会按照：背景 —&gt; 需求 —&gt; 自己开发 —&gt; 性能对比 —&gt; 源码解析—&gt; 八股分析 —&gt; 背诵要点总结</p><p>那么，就开始把。</p><p>2021年4月26日总第一期：<a href="https://yzhao.top/posts/myHashMap.html">&lt;&lt;徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样&gt;&gt;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
