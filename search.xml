<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java常见核心命题</title>
      <link href="posts/javaInit.html"/>
      <url>posts/javaInit.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java常见核心命题"><a href="#Java常见核心命题" class="headerlink" title="Java常见核心命题"></a>Java常见核心命题</h1><h2 id="本章思维导图"><a href="#本章思维导图" class="headerlink" title="本章思维导图"></a>本章思维导图</h2><p><img src="/posts/javaInit/img1.png" alt="思维导图"></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ol><li><p><strong>抽象与接口</strong></p><ul><li>抽象是对类的抽象，为了解决代码复用，表示is-a的关系。是一种自下而上的设计思路，先有子类的代码重复，才有抽象上层父类；</li><li>接口是对行为的抽象，侧重于解耦，实现了约定和实现的分离，表示has-a的关系。是一种自上而下的设计思路，先设计好接口，再考虑具体实现。</li></ul></li><li><p><strong><code>final</code>关键字</strong></p><ul><li>final修饰变量：不可被修改</li><li>final修饰参数：在函数里不可被修改</li><li>final修饰方法：不可被重写（private级别的方法默认都是final）</li><li>final修饰类：不可被继承</li><li><strong>final修饰对象类型变量</strong>，仅引用不可变</li></ul></li><li><p><strong><code>static</code>关键字</strong></p><ul><li>静态变量：类变量（属于类而非属于实例），所有实例共享，在内存中只有一份，会在类初始化的时候赋系统默认值（final修饰的除外）。<strong>基本类型</strong>会将值存储在方法区，而<strong>引用类型</strong>在方法区存储的是引用/堆地址</li><li>静态方法：必须有实现，不可为抽象方法。</li><li>静态代码块：仅类初始化运行一次，先父后子。</li><li>静态内部类：<ul><li>在外部类的非静态方法中，使用方式没有差别</li><li>在外部类的静态方法以及在其他类中，如果要使用，非静态内部类需要new Outter().new Inner();来实现，而静态内部类只需new Inner()即可。故，内部类都写成静态的</li></ul></li><li>静态导包：静态方法或者变量的使用方式是Class.method/var，采用静态导包之后，可以直接使用method而不必指明Class</li></ul></li><li><p><strong>泛型</strong></p><ul><li>概念：参数化类型（区别于参数化变量）；仅在编译阶段有效，编译时的类型安全检测机制；运行期泛型消失（类型擦除）</li><li>分类：泛型类 &amp; 泛型接口 &amp; 泛型方法</li><li>类型通配符：<ul><li><code>&lt;?&gt;</code>无界通配符</li><li><code>? extends Type</code> 上边界通配符，只读不写，如list只能get而不能add()</li><li><code>? super Type</code> 下边界通配符，只写不读，如list只能返回Object，作为函数返回类型没有意义</li><li>通配符限定的范围是在确定”<strong>参数化类型</strong>“的时候</li></ul></li></ul></li><li><p><strong>缓存池</strong></p><ul><li><p>基本类型缓存池，如果对应包装类型的数值范围在缓存池内，直接使用缓存池中的对象</p><ul><li><p>Code Demo: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">123</span>; <span class="comment">// Integer.valueOf(123)</span></span><br><span class="line">Integer b = <span class="number">123</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br><span class="line">Integer a = <span class="number">129</span>;</span><br><span class="line">Integer b = <span class="number">129</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>Integer/short的范围为-128～127</p></li></ul></li><li><p>String类型缓存池，保存所以String字面量，同时还可以inter()进行添加</p><ul><li>inter(): 添加进String pool中返回该字符串的引用</li></ul></li></ul></li></ol><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>较为详细的核心原理请参考<a href="https://yzhao.top/posts/myHashMap.html">徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样</a></p><ul><li><p>数据结构：数组（桶）+链表（拉链法）</p></li><li><p>hash计算公式以及优势：</p><ul><li>借助Object类的hashCode()</li><li><code>h=h^(h&gt;&gt;&gt;16)</code> 这里的改进就是高16位与低16位异或，主要优化低16位相等时的哈希值，减少哈希冲突</li><li><strong>寻址算法</strong>：<code>n=(n-1)&amp;h</code>本质是对n求模，即<code>h%n=h&amp;(n-1)</code>，尤其是当n为2的n次幂时寻址更加均匀，所以默认的HashMap的长度为<code>1&lt;&lt;&lt;4</code></li></ul></li><li><p>加载因子为什么设置为0.75？过大哈希冲突的概率增加；过小则浪费空间，频繁扩容</p></li><li><p><code>V put(K key, V value)</code> 新增KV对流程：</p><ul><li>hash算法：得到桶下标，即<code>i = (n-1)&amp;h</code></li><li>若桶数组为空，扩容</li><li>若当前桶下标为空，newNode，即<code>tab[i]=new Node&lt;&gt;(hash, key, value, next)</code></li><li>若当前桶下标有值，即<strong>哈希冲突</strong>，采用拉链法解决<ul><li>创建临时节点e</li><li>若<code>p.hash == q.hash &amp;&amp; p.key == q.key &amp;&amp; p.key.equals(q.key) =&gt; e = p</code></li><li>若是红黑树，则使用红黑树的方式新增</li><li>若是链表<ul><li>遍历结束，证明是新增节点，所在尾端新增node</li><li>如果在循环过程中发现有相同的key的时候，证明是覆盖节点，此时该节点为e，结束循环；</li></ul></li><li>最后，对相同的key，如果运行覆盖value，则此时进行value值覆盖，并返回oldvalue</li></ul></li><li>若当前HashMap的<code>size&gt;threshold</code>（首次扩容=0.75*16=12）时，扩容<br>具体新增流程为：<br><img src="/posts/javaInit/img2.png" alt="HashMap之put方法"></li></ul></li><li><p><code>Node&lt;K, V&gt;[] resize()</code> 扩容</p><ul><li>记录现有的capacity以及现有的Threshold</li><li>不可超过最大MAXMUM_CAPACITY且扩容为现在的2倍</li><li>若链表长度为1，直接赋值</li><li>若该节点是红黑树，则进行相关操作</li><li>若链表不为1，进行<strong>链表复制</strong>，JDK1.8优化：<ul><li>若e.hash &amp; oldCap == 0，还是用原索引，放在原来的桶里</li><li>若e.hash &amp; oldCap == 1，放在新的桶里，新的索引=原索引+oldCap</li></ul></li><li><strong>优化点</strong>：在进行链表复制的时候，通过e.hash &amp; oldCap 的结果来判断新的索引地址  </li></ul></li><li><p><code>V get(Object key)</code> 查找</p><ul><li>计算key的hash值，以及桶下标</li><li>若链表的第一个节点的key就是目标key，则返回该节点(e.val)</li><li>否则，进行循环遍历判断key是否是目标key</li><li>若某一个节点位红黑树节点，则使用红黑树的方式遍历</li></ul></li><li><p><strong>并发场景梳理</strong></p><ul><li>HashMap是非线程安全的，不保证线程获取数据的一致性</li><li>链表成环问题（JDK1.8已经修复）:<ul><li>扩容流程：<code>next=e.next -&gt; tab[i]=e -&gt; e = next</code></li><li><strong>风险点</strong>：这里采用的是头插法插入节点，会改变链表原来节点的顺序<br><img src="/posts/javaInit/img3.png" alt="JDK1.7链表成环核心原因分析图示"></li></ul></li></ul></li></ul><p>注意：HashMap依旧是线程不安全的，所产生的线程问题无非就是同一份数据被不同的线程所改变造成的（<strong>即原子性被打断</strong>）。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>核心</strong>：CAS + synchronized<br>Node&lt;K,V&gt; table采用了<strong>volatile</strong>来修饰<br>hash函数的小改进：(h^(h&gt;&gt;&gt;16))&amp;HASH_BITS HASH_BITS主要是为了消除符号位置，即MAX_VALUE;因为在ConcurrentHashMap中的hash需要表示正在转移(-1)、转移成树(-2)以及保留值(-3)<br><code>V put(K key, V value) </code></p><ul><li>数组为空，初始化；</li><li>若当前槽点没有值，CAS创建节点，失败自旋（for循环）</li><li>若槽点有值，判断当前槽点是不是MOVED节点，如果是，会参与扩容</li><li>若槽点有值且扩容完成，锁定当前槽，链表尾插</li><li>线程安全的手段：<ul><li>数组初始化通过自旋+CAS+double check保证初始化成功 initTable()</li><li>新增节点时：<ul><li>自旋确保一定可以成功；</li><li>槽点为空时，通过CAS新增，如果失败，则自旋；</li><li>槽点有值，锁槽点</li><li>红黑树旋转时，锁root</li></ul></li></ul></li></ul><p><code>void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) </code></p><ul><li>拷贝数组时从尾部开始；</li><li>拷贝槽点，锁原数组槽点，拷贝完成时，原数组槽点赋值为ForwardingNode</li><li>此时如果有put到此槽点时，发现时MOVED会参与增加线程帮助扩容</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li><p>原理：无锁 –&gt; 偏向锁 –&gt; 轻量级锁 –&gt; 重量级锁</p></li><li><p>使用方式：</p><ul><li><strong>类锁</strong>：类共有的，不同的实例也会被锁住；除此之外，还有String的字面量赋值以及基本数据类型的包装类型在缓存池范围内的情况下</li><li><strong>对象锁</strong>：实例共有，同一个实例才会被锁住</li></ul></li></ul><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><ul><li>新建状态new，线程创建但未启动</li><li>就绪状态runnable，调用start()</li><li>运行状态running，获得CPU执行时间片</li><li>阻塞状态blocked，同步阻塞；主动阻塞；被动阻塞</li><li>终止状态dead</li></ul><h3 id="Java创建线程方法"><a href="#Java创建线程方法" class="headerlink" title="Java创建线程方法"></a>Java创建线程方法</h3><ul><li><code>class A extends Thread&#123;&#125;</code> 继承Thread类，并重写run()方法；</li><li><code>class B implements Runnable</code>实现Runnable接口，作为Thread参数</li><li><code>class C implements Callable&lt;T&gt;</code>实现Callable接口，作为Future的参数，Future再作为Thread的参数，可接受返回值</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 class A extends Thread</span></span><br><span class="line"><span class="keyword">new</span> A().start();</span><br><span class="line"><span class="comment">//2 runnable</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;....&#125;).start(); <span class="comment">// 用lambda表达式来实现runnable</span></span><br><span class="line"><span class="comment">//3 callable</span></span><br><span class="line">Future&lt;Integer&gt; future = <span class="keyword">new</span> Future&lt;&gt;(()-&gt;&#123;....&#125;); <span class="comment">// 用lambda来实现callable</span></span><br><span class="line"><span class="keyword">new</span> Thread(future).start();</span><br><span class="line">System.out.println(future.get()); <span class="comment">// 获得返回值</span></span><br></pre></td></tr></table></figure><p>无论哪种方式，本质都是<code>new Thread()</code> 无非使用了不同的start方法</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li>当该线程执行完某一项功能之后，可以调用this.notify() or this.notifyAll()方法来唤醒所有阻塞的线程，再使用this.wait()是自己进入阻塞状态<ul><li>注意：一定要先唤醒，否则一旦自己陷入阻塞状态的时候，是不会释放锁的</li></ul></li></ul><p>交替打印奇偶：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printOdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span> != <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printEven</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i%<span class="number">2</span> == <span class="number">0</span>) System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">                <span class="keyword">this</span>.notifyAll();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadTest::printOdd, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(threadTest::printEven, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了原始的notify与wait方法，J.U.C还提供其他好用的同步工具</p><ul><li>CountDownLatch，当计数器为0时，在CountDownLatch上await的线程会被唤醒；适用于等待所有子线程全部完成之后再做操作的场景，可以类比join</li><li>CycliBarrier，等待所有线程到达统一状态，再进行全部同时执行<ul><li>使用await进行阻塞，等待所有线程都执行到await之后，再同时执行后续操作；而且支持可重复使用</li><li><code>new CycliBarrier(nums)</code> 表示能控制几个线程，大于这个数目的线程不受CycliBarrier控制</li></ul></li><li>Semaphore，前两个是内部维护一个状态码，判断是否为0，而信号量是增加的机制<ul><li><code>semaphore.release()</code> 使得信号量+1；</li><li><code>semaphore.acquire(nums)</code>阻塞，等待信号量累加到nums的值，才进行执行代码</li></ul></li><li>Condition,需要Lock来通过newCondition()进行调用<ul><li><code>condition.signalAl()</code></li><li><code>condition.await()</code></li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>核心逻辑</strong>：</p><p><img src="/posts/javaInit/img4.png" alt="线程池执行图"></p><ul><li>直接执行：分配线程，从corePoolSize或者maximumPoolSize中获取</li><li>缓冲执行：放入阻塞队列，等待被任务getTask()</li><li>任务拒绝：缓冲队列已满</li></ul><p><strong>核心参数</strong></p><p><code> new ThreadPoolExecutor</code></p><ul><li><code>int corePoolSize</code> 常驻核心线程数<ul><li>如果等于0，则任务执行完毕之后，没有任何请求进入时，销毁线程；</li><li>如果大于0，则本地线程执行完毕，也不会销毁线程；</li></ul></li><li><code>int maximumPoolSize</code>线程池可以容纳的同时执行的最大线程数<ul><li>必须大于等于1</li><li>如果待执行的线程数大于此值，则需要缓存在workQueue中</li></ul></li><li><code>long keepAliveTime</code> 线程池中线程空闲时间<ul><li>当空闲时间达到KeepAliveTime时，线程会被销毁，直到剩下corePoolSize个线程为止</li><li>默认情况下，当线程池的线程数大于corePoolSize时才会起作用</li><li>当allowCoreThreadTimeOut=true时，核心线程超时也会被回收</li></ul></li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>：阻塞队列<ul><li>当线程数大于maximumPoolSize时，线程进入线程进入BlockingQueue阻塞队列</li></ul></li><li><code>ThreadFactory threadFactory</code> 线程工厂</li><li><code>RejectedExecutionHandler handler</code>执行拒绝策略的对象<ul><li>当超过缓存队列的任务缓存区上限的时候，可以通过该 策略处理请求（限流保护）</li></ul></li></ul><p><strong>核心步骤</strong>：</p><ol><li>当一个线程到来的时候，如果常驻线程数大于1，且正在运行的线程数小于常驻，则调用常驻线程来执行该任务；</li><li>若常驻线程已满，若当前运行总线程数小于最大线程数，则创建新线程来执行；</li><li>若当前运行的线程数已满，则进入工作队列等候</li></ol><p><strong>其余线程池类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ScheduledThreadPoolExecutor extends ThreadPoolExecutor implements ScheduledExecutorService&#123;...&#125;</span><br><span class="line"></span><br><span class="line">ForkJoinPool extends AbstractExecutorService &#123;...&#125;</span><br></pre></td></tr></table></figure><p><strong>工作队列 BlockingQueue</strong></p><ul><li><code>LinkedBlockingQueue&lt;Runnable&gt;</code><ul><li>主要为FixedThreadPool以及SingleThreadPool，且都用的是无界队列，容易造成OOM</li><li>LinkedBlockingQueue也支持设置为有界队列</li></ul></li><li><code>SynchronousQueue&lt;Runnable&gt;</code><ul><li>不存储元素的阻塞队列，用于<code>newCachedThreadPool</code></li><li>其基本流程就是：当线程池没有足够的线程能够执行新的任务时，该队列的offer方法会失败，那么ThreadPoolFactory会新建线程处理该任务</li></ul></li><li><code>DelayWorkQueue()</code>优先级队列，会按照任务的延时时间进行排序</li></ul><p><strong>拒绝策略</strong></p><p>饱和策略，当队列和线程池都满了的时候，说明此时线程池处于饱和策略，必须采取一种策略来处理新提交的任务，默认是AbortPolicy</p><ul><li>AbortPolicy：直接抛出异常，拒绝策略</li><li>CallerRunsPolicy: 只用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy: 丢弃队列里最近的一个任务</li><li>DiscardPolicy: 不处理，丢弃掉</li></ul><p><strong>任务提交</strong></p><ul><li>execute()用于提交不需要返回值的任务，接受的是一个Runnable</li><li>submit()用于提交需要返回值的任务，接受的是一个Callable或者是Runnable</li></ul><h3 id="Executors实现的常用线程池工具（五大）"><a href="#Executors实现的常用线程池工具（五大）" class="headerlink" title="Executors实现的常用线程池工具（五大）"></a>Executors实现的常用线程池工具（五大）</h3><blockquote><p>根据new ThreadPoolExecutors修改不同参数</p></blockquote><p><strong>固定线程池</strong></p><p>newFixedThreadPool(n)称之为，固定线程数线程池，即核心线程数等于最大线程数，keepAliveTime为0；如果线程池中的所有线程都处于活动状态，此时再提交任务就在队列中等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThread,nThread,<span class="number">0L</span>,TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缓存线程池</strong></p><p>newCachedThreadPool() 是最大线程数没有限制，如果线程池中的线程在60s内未被使用，就会被移除；在执行新的任务的时候，当线程池中有之前创建的可用线程就重用可用线程，否则创建新的线程，所以称之为可缓存线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>,TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定时线程池</strong></p><p>newScheduledThreadPool(n) 创建一个支持定时及周期性的任务执行的线程池；</p><ul><li>该线程池返回的需要指明是ScheduledExecutorService；</li><li>initialDelay &amp; period 初始延迟 &amp; 周期</li><li>附录：Timer类，timer.schedule() 同样可以完成定时任务的执行</li></ul><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 其中之一 构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, TimeUnit.NANOSECONDS, <span class="keyword">new</span> DelayWorkQueue(), threadFactory)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用范例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//延迟1S, 定时任务每3秒执行一次，执行的内容为Runnable的实现</span></span><br><span class="line">  executor.scheduleAtFixedRate(()-&gt;System.out.println(<span class="number">1</span>), <span class="number">1</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单线程线程池</strong></p><p>newSingleThreadExecutor()只有一个线程的线程池，等同于单线程串行执行所有任务，保证任务提交顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0L</span>,TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>并行线程池</strong></p><p>newWorkStealingPool() 需要的参数是一个并行数，不保证任务的顺序执行，抢占式工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool(parallelism, ForkJoinPool.defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">        checkFactory(factory),</span><br><span class="line">        handler,</span><br><span class="line">        asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">        <span class="string">&quot;ForkJoinPool-&quot;</span> + nextPoolId() + <span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                         ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                         UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                         String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JMM-Java内存模型"><a href="#JMM-Java内存模型" class="headerlink" title="JMM(Java内存模型)"></a>JMM(Java内存模型)</h3><p>共享内存并发模型与消息传递并发模型。前者同步是显式进行的；后者是隐式执行的</p><p>JMM采用的是共享内存并发模型：</p><p><img src="/posts/javaInit/img5.png" alt="JMM"></p><p>JMM定义了线程和主内存之间的共享关系：</p><ul><li>线程之间的共享变量存储在主内存中</li><li>每个线程有一个私有的本地内存，存储了共享变量的副本</li></ul><p>JMM解决的问题</p><ul><li>内存可见性</li><li>指令重排序<ul><li>编译器优化重排序</li><li>指令集并行重排序</li><li>内存系统重排序</li></ul></li></ul><p>volatile：禁止指令重排（happens-before）；本地内存修改完毕立刻同步主内存</p><p>happens-before：前一个操作结果对后一个操作可见，并不一定要求前一个必须先执行；如果不满足这个规则，JVM可以对他们任意重排序</p><ul><li>程序顺序规则：一个线程中的每个操作，必须happens-before于该线程中任意后续操作</li><li>监视器锁规则：对一个监视器的解锁，必须happens-before于随后对这个监视器的加锁</li><li>volatile变量规则：对于一个volatile域的写，必须happens-before于任意后续对这个volatile域的读</li><li>传递性：if A happens-before B, B happens-before C那么 A happens-before C</li></ul><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS: AbstracQueuedSynchronizer抽象同步队列</p><p><strong>基本场景</strong>：加锁；释放锁；等待；唤醒</p><p><strong>state状态维护</strong>：</p><ul><li>volatie修饰，保证内存可见性</li><li>getState以及setState禁止子类重写</li><li>compareAndSetState()采用乐观锁CAS</li></ul><p><strong>CLH队列</strong>（FIFO的双向队列）</p><ul><li>当前线程获取state失败，AQS会构建节点加入CLH同步队列中，阻塞该线程；</li><li>当同步状态释放时，会把首节点唤醒（公平锁），使其尝试获取同步状态</li></ul><p><strong>Condition通知机制，维护了等待队列</strong></p><ul><li>调用了await()方法的线程，加入到Condition等待队列，同时唤醒CLH队列的下一个节点；</li><li>线程中调用了signal()方法后，Condition等待队列的首位等待任务会被加入CLH队列中，等待被唤醒</li><li>当线程调用unLock()方法后，CLH队列下一个节点会被唤醒</li></ul><p>独占和共享模式</p><p>自定义同步器。摘抄自《Java并发编程之美》</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>,<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueueSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1 锁是否被持有 1被持有</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> arg == <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(compareAndSetState(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">      <span class="keyword">assert</span> arg==<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(getState==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">      setState(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4 返回Condition</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span><span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ReentrantLock</strong></p><ul><li>lock.lock()</li><li>lock.unlock()</li><li>lock.newConditoin()</li></ul><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>Unsafe：</p><ul><li>compareAndSwapObject</li><li>compareAndSwapInt</li><li>compareAndSwapLong</li><li>…</li></ul><p>AtomicXXX</p><p>CAS是Java Unsafe类中实现的操作，是native方法，其是一种<strong>无锁的编程手段</strong>，全称是 Compare And Set。CAS(V,A,B) 将V上的值与A做比较，如果相等，则更新为B;否则，禁止更新，返回V的值</p><p>CAS的核心问题</p><ul><li>ABA问题：所谓ABA问题，指的是一个值由A变成了B，又变成了A，我此时使用CAS去赋值的时候，认为没有变化，则会进行赋值，但是实际上已经变化了。解决方案就是增加版本号</li><li>ABA主要的例子：如果一个链表的A.next被修改过，虽然A还是A，但是其实最终的结果和我们想要的不一样</li><li>循环时间长，开销大</li><li>只能保证一个共享变量的原子操作</li></ul><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><strong>原理</strong>：静态内部类维护了ThreadLocalMap，维护了实例(V)与ThreadLocal(K)的映射；其中，key是弱引用，但是value是强引用，依旧会出现内存泄露的问题</p><p>场景：</p><ul><li>ThreadLocal不能解决线程间数据共享的问题（因为其只是线程本地变量）</li><li>ThreadLocal隐式的在不同线程创建独立实例副本避免线程安全</li><li>ThreadLocalMap维护了ThreadLocal(与线程挂钩)与Object的映射</li><li>ThreadLocal适用于变量在线程间隔离且在方法间共享的场景</li></ul><h3 id="J-U-C相关工具"><a href="#J-U-C相关工具" class="headerlink" title="J.U.C相关工具"></a>J.U.C相关工具</h3><p>CompletableFuture，是属于ForkJoin的实现</p><ul><li>异步提交任务的方法supplyAsync()或者是runAsync() 前者接受返回值，后者没有返回值</li><li>有其他来进行多个任务串联进行的方式，如thenApply()等</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-内存划分"><a href="#JVM-内存划分" class="headerlink" title="JVM 内存划分"></a>JVM 内存划分</h3><p><img src="/posts/javaInit/img6.png" alt="JVM内存"></p><p><strong>线程私有</strong>：程序计数器，JVM Stack，原生方法栈，<br><strong>线程共享</strong>：Heap，元空间</p><p><strong>程序计数器</strong>，JVM为每一个线程分配一个程序计数器，如果线程正在执行Java方法，则记录正在执行的虚拟机字节码指令地址，native方，则为空；且，没有规定OutOfMemoryError的区域</p><p><strong>Java虚拟机栈</strong>，每个方法在执行的时候都会创建一个栈帧，存储局部变量表，操作数栈，动态链接，方法出口。方法调用对应一个栈帧从入栈到出栈的过程</p><ul><li>局部变量表：方法参数 &amp; 局部变量(基本数据类型和对象引用)</li><li>操作数栈：FIFO</li><li>动态链接：方法调用的目的确定调用方法的版本，运行期间才确定直接引用</li><li>方法出口：即弹出当前栈</li></ul><p><strong>本地方法栈</strong>，等价于Java虚拟机栈，只不过一个是调用Java方法，一个是调用本地native方法，通过JNI直接调用本地C/C++库</p><p><strong>元空间（方法区）</strong>：被虚拟机加载的类信息，final常量，静态变量，编译器即时编译的代码；常量池（Class文件常量池，运行时常量池，全局字符串常量池，基本类型包装类对象常量池）</p><p><strong>堆</strong>：存储对象实例，GC堆，在分代回收思想中：新生代：Eden + survivor + survivor (8:1:1) ； 老年代</p><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>分代回收算法</p><ul><li>Serial：单线程标记复制算法</li><li>ParNew：Serial的多线程版本</li><li>Parallel Scavenge：ParNew的升级版本，主要提供了最大垃圾回收停顿时间以及垃圾回收时间占比两个参数，可以适当的控制回收节奏，关注于吞吐率</li><li>Serial Old：标记整理算法</li><li>Paralle Old</li><li>CMS：初始标记(STW) - 并发标记 - 再标记(STW) - 并行清理</li></ul><p>G1，将堆划分为大小相等，内存连续的Region区域，每个Regioin对应Eden, Survivor，Old，Humongous四种角色之一</p><ul><li>初始标记阶段(STW) - 并发标记阶段 - 重新标记阶段(STW) - 清理阶段</li><li>SATB</li><li>RSets</li><li>停顿预测模型</li><li>Young GC &amp; Mixed GC</li></ul><h3 id="GC性能优化参数"><a href="#GC性能优化参数" class="headerlink" title="GC性能优化参数"></a>GC性能优化参数</h3><p>相关参数</p><ul><li>-XX:+printGCDetails</li><li>-Xms 堆空间初始大小</li><li>-Xmx 堆空间最大大小</li><li>-XX:+UseG1GC</li><li>-XX:G1HeapRegionSize</li><li>-XX:MaxGCPauseMillis</li><li>-XX:InitiatingHeapOccupancyPercent 当堆内存使用占比大于这个比率会触发并发GC周期</li></ul><p>架构优化 + 代码优化 - 明确优化目标 - 对症下药</p><h3 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h3><p>类的生命周期：加载、链接、初始化、使用和卸载，其中（加载、链接、初始化）属于类加载过程</p><p>类加载过程：加载 - [ 验证 - 准备 - 解析] - 初始化 ; []即链接</p><ul><li>加载：<ul><li>类的全限定名拿到.class二进制字节流</li><li>内存中生成一个Class对象放在方法区</li></ul></li><li>链接<ul><li>验证：确保class字节流的信息符合虚拟机要求</li><li>准备：为类中的静态字段分配内存，设置默认初始值</li><li>解析：JVM将常量池中的符号引用转换为直接引用的过程</li></ul></li><li>初始化：执行类构造器<code>clinit()</code>方法的过程<ul><li>clinit() 是由编译器自动收集所有变量的赋值动作和static代码快的内容</li><li>虚拟机保证父类的类构造器先执行完</li><li>如果没有赋值和static，则不会执行类构造器</li></ul></li></ul><p>类加载器：通过全限定名拿到二进制字节流的动作使用类加载器来实现</p><ul><li>启动类加载器：C/C++实现，嵌套在JVM内部，Java程序无法操作，用来加载核心类库</li><li>扩展类加载器：继承自ClassLoader，父类加载器是启动类加载器；用加载系统属性指定的类库</li><li>应用程序类加载器：继承自ClassLoader，父类加载器是启动类加载器；负责加载环境变量指定下的类库；默认类加载器，Java程序中的类由其加载</li><li>自定义类加载</li></ul><p>双亲委派模型</p><p><img src="/posts/javaInit/img7.png" alt="双亲委派模型"></p><p>要求：除了顶层的启动类加载器外，必须有自己的父类加载器（通过组合而非继承来复用代码）<br>工作原理：委托父类加载器进行类加载<br>好处：Java类同其类加载器一起具备了带有优先级的层次关系<br>双亲委派模型的破坏者——线程上下文类加载器</p><h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><blockquote><p>IO主要用来处理网络、磁盘等数据交互</p></blockquote><h3 id="传统IO模型"><a href="#传统IO模型" class="headerlink" title="传统IO模型"></a>传统IO模型</h3><p>按照数据源，对io来做一个大方向的分类：文件、数组、管道、基本数据类型、缓冲、打印、序列化与反序列化、转化 </p><p>按照数据传输方式：字符流Reader &amp; Writer与字节流InputStream &amp; OutputStream</p><p><img src="/posts/javaInit/img8.png" alt="字节流与字符流"></p><h3 id="网络IO模型"><a href="#网络IO模型" class="headerlink" title="网络IO模型"></a>网络IO模型</h3><p><strong>Java BIO</strong></p><p><img src="/posts/javaInit/img9.png" alt="BIO"></p><p>原理：每个连接对应一个线程<br>问题：严重依赖线程<br>关键：<br>accept() 会阻塞等待客户端的连接<br>引入线程池可以缓解线程频繁创建的开销，但本质依旧没有改变，连接数少的时候，开发维护以及性能都很好<br>代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/18 7:23 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServerSocket serverSocket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPort</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverSocket.getLocalPort();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8081</span>);</span><br><span class="line">            Executor executor = Executors.newFixedThreadPool(<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                RequestHandler requestHandler = <span class="keyword">new</span> RequestHandler(socket);</span><br><span class="line">                <span class="comment">//requestHandler.start();</span></span><br><span class="line">              executor.execute(requestHandler);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DemoServer server = <span class="keyword">new</span> DemoServer();</span><br><span class="line">        server.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (Socket client = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), server.getPort())) &#123;</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            bufferedReader.lines().forEach(s -&gt; System.out.println(s));</span><br><span class="line">        &#125;  <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    RequestHandler(Socket socket) &#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream())) &#123;</span><br><span class="line">            out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java NIO</strong></p><p>核心步骤：</p><ul><li>Selector.open()创建一个Selector；</li><li>创建一个ServerSocketChannel，并注册到Selector注册，通过制定SelectionKey.OP_ACCEPT，用来处理新的连接请求</li><li>Selector阻塞在select()操作，当有channel发生接入请求时，会被唤醒</li><li>NIO利用了单线程轮询事件机制，仅select()阻塞</li></ul><p>核心框架</p><p><img src="/posts/javaInit/img10.png" alt="NIO"></p><p>ServerSocketChannel：监听新来的TCP连接，对每一个新来的TCP连接创建一个SocketChannel<br>SocketChannel：通过TCP读写网络中的数据</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhaoyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/19 12:36 下午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1 打开一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//2 打开一个channel,并注册到该selector上，同时绑定一socket的ip&amp;port</span></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT); <span class="comment">// 必须先有OP_ACCEPT创建连接的channel</span></span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line">        <span class="comment">//3 循环阻塞，阻塞在select(),这证明selector一直在等待创建连接的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            <span class="comment">//4 一旦发现连接，将不会阻塞，得到这个连接的状态</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//5 最首先带来的一定是创建连接的通信，然后创建连接，同时再创建另外一个channel用来与客户端通信，如OP_READ</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="comment">// 将这个channel重新注册到selector上，</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">// 通过SocketChannel通信</span></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据socketChannel创建数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = socketChannel.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = byteBuffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) byteBuffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NIO与BIO的区别</p><ul><li>NIO是以块的方式处理数据；BIO是以字节流的形式处理数据</li><li>NIO基于缓冲，BIO基于流；而缓冲是双向的，流是单向的</li><li>NIO基于单线程轮训处理连接；BIO每一个连接都需要创建线程</li></ul><p><strong>Java AIO</strong></p><p>核心使用Future来表示异步操作的结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> 八股战神系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样</title>
      <link href="posts/myHashMap.html"/>
      <url>posts/myHashMap.html</url>
      
        <content type="html"><![CDATA[<h1 id="徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样"><a href="#徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样" class="headerlink" title="徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样"></a>徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>反思我们在项目中，或者生活中，遇到的最多的一个结构，应用最为频繁的一个结构，应该是什么？</p><p>数组？链表？树？图？</p><p>如果，让我来选择一个皇冠，我愿意将它戴在散列表的头上。</p><p>散列表，就是我们熟知的Map。我们想象一下的他的结构，键值对的结构，在现在的代码社会里几乎无所不在，万物皆对象，对象就是变量名与值的对应，不同的是，对象的Key我们一般事先定义好。亦或者，现在极其普遍的Json结构，其本质也是键值对的结构。</p><p>那么，我们为什么会需要这样一个结构呢？</p><p>众所周知，数组是程序世界的基石。我甚至都不愿意把皇冠给它，因为它乃基石。数组的一大特点是连续内存存储，所以他有一个优势，即按照下标，我们读取一个数值的时间复杂度是o(1)。</p><p>但是数组有一个前提，按照下标。</p><p>可不可以有一个不需要固定下标，也可以实现随机o(1)复杂度的访问的数据结构？</p><p>当然有，这就是我们的重点——键值对，即我们需要一个维护key以及该key所对应的value的一个键值对的数据结构。</p><h2 id="自制HashMap"><a href="#自制HashMap" class="headerlink" title="自制HashMap"></a>自制HashMap</h2><h3 id="弄清需求，搭建框架"><a href="#弄清需求，搭建框架" class="headerlink" title="弄清需求，搭建框架"></a>弄清需求，搭建框架</h3><p>在我个人浅薄的知识面下，我的第一反应是，键值对作为一个对象，因为我要存储一堆键值对，那么，很自然的会写出如下的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node[] kvArr = <span class="keyword">new</span> Node[size];  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但，</p><p>我么假如使用上述结构，那么，我们如何实现根据K获得V这一功能呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Node node:kvArr)&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.k.equals(key)))&#123;</span><br><span class="line">        <span class="keyword">return</span> node.v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个什么鬼的数据结构 </p><p>所以大家可以明白了，底层使用的数组，却得到了更差劲儿的性能？</p><p>那么我们可不可以优化增加的逻辑，使得Node不是随便加？</p><h3 id="测试逻辑，完善框架"><a href="#测试逻辑，完善框架" class="headerlink" title="测试逻辑，完善框架"></a>测试逻辑，完善框架</h3><p>要明白的一点，要想使得查询不遍历，那么增加也不得随意，必须按照一定的规则</p><p>什么规则？</p><p>最简单的角度，我是不是可以把k与下标做一个函数关联？</p><p>比如，经过计算，<code>f(k) = i</code> 的放在下标<code>i</code>的位置里</p><p>那么，我们可以增加一个如上函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key.hashCode() % capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要解释两个东西</p><ul><li>hashCode(). hashCode是Object类的基本属性，用来对每一个对象计算一个数值</li><li>capacity。我们最终得到的数值是需要放在长度为capacity的数组中的，所以需要取余，以免越界。至于capacity的取值，这里先xjb等于10</li></ul><p>所以，无论是增加还是查询，都需要借助该hash函数，所以，灵魂是谁，一目了然</p><p>增加功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    kvArr[hash(key)] = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> kvArr[hash(key)].getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是觉得很完美</p><p>不</p><p>现在，才刚刚入门</p><p>这个所谓的优化，有两个极其大的漏洞</p><ol><li><p>size如果一旦确定。用尽了怎么办？</p></li><li><p>hash值，相等怎么办</p></li></ol><h3 id="深入优化，完成框架"><a href="#深入优化，完成框架" class="headerlink" title="深入优化，完成框架"></a>深入优化，完成框架</h3><p>所以，我们遇到了hash结构的第一个核心问题，那就是hash冲突</p><p>如何解决hash冲突呢？</p><p>很简单的方式，在add函数里增加判断，如果计算该hash值所在数组有值，则增加到下一个位置，如果还有值，继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">//循环判断是否有值</span></span><br><span class="line">    <span class="keyword">while</span> (kvArr[hash] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    kvArr[hash] = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>!!!</p><p>当我们修改add函数的同时，不要忘记了，查询和新增永远是相辅相成的。</p><p>那么我们查询也需要依赖冲突算法，那么我们该如何解决？</p><p>这里有一个直接的想法，就是如果在add的时候，解决了几次冲突，我们可以记录下来冲突的次数就好了？</p><p>这里我脑子里出现的第一个思路是：记录下来次数，当我get的时候按照既定次数去计算即可。</p><p>但，次数记载哪里？</p><p>我们在add的时候，解决冲突的次数是不确定的，他是一个随机往后寻找位置的一个过程。而我们在查找的时候，只有一个key以及根据这个key第一次hash计算出来的Node的节点。</p><p>那么，记录次数似乎不可以，我们还有什么？</p><p>我们有key以及node节点的key啊！</p><p>key的值一样不就可以了？！！！</p><p>所以，代码就简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (!kvArr[hash].getKey().equals(key)) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kvArr[hash].getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>聪明的小伙伴，我猜你一定知道了些什么。</p><p>是的，这就是大名鼎鼎的<strong>散列表之线性探测法</strong></p><h3 id="最终结果，落地可用"><a href="#最终结果，落地可用" class="headerlink" title="最终结果，落地可用"></a>最终结果，落地可用</h3><p>上述解决了我们的一个核心问题，那就是hash冲突，实际上这属于hash函数的设计范畴。</p><p>还有另外一个核心问题，我们的初始化size用尽了，怎么办？</p><p>扩容呀</p><p>在扩容的时候，我们在这里需要提前明确两个概念：</p><ul><li>size. size指的是当前Map中已经有KV对的数量</li><li>capacity. capacity的含义是，目前Map可以承载的最大KV对的数量</li></ul><p>明确了这两个概念之后，所谓扩容，指的是，当size==capacity的时候或者说逼近，扩大capacity的容量</p><p>那这里需要首先提供，size的计算方法，在每次执行put的时候，相当于size加了一。</p><p>所以，Map的增加函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; node = <span class="keyword">new</span> Node&lt;K, V&gt;(key, value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size == capacity) &#123;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (kvArr[hash] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        hash = (hash + <span class="number">1</span>) % capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    kvArr[hash] = node;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>明白了什么时候调用resize函数之后，我们接下来要做的是，集中精力编写resize函数。我们先来搞清楚几个关键点：</p><ul><li>capacity需要扩大多少？</li><li>原来的数据如何放到扩容后的数组中？</li></ul><p>针对第一个问题，我们就简单的扩容2倍</p><p>对于第二个问题，我相信很多人的直接就是纯碎的拷贝。但实际上，我们如果能重新计算Hash，重新改变位置，才是更合适的。这里的问题就是，更好的解决hash冲突问题。其实hash的关键问题，就是如何巧妙的额设计，避免hash冲突。因为，hash冲突之后，按照线性探测的方法，我们需要更多的循环，这会严重影响HashMap的性能</p><p>所以，我们设计的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tmp = <span class="keyword">new</span> Node[<span class="keyword">this</span>.capacity];</span><br><span class="line">    System.arraycopy(kvArr, <span class="number">0</span>, tmp, <span class="number">0</span>, tmp.length);</span><br><span class="line">    <span class="keyword">this</span>.capacity = <span class="keyword">this</span>.capacity * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">this</span>.kvArr = <span class="keyword">new</span> Node[<span class="keyword">this</span>.capacity];</span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; node:tmp) &#123;</span><br><span class="line">        <span class="keyword">this</span>.put(node.getKey(), node.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，我的思路是，先把当前的数组<strong>浅拷贝</strong>一份，然后用扩容后的数组替换掉当前的数组，此时，该数据capacity为之前的2倍，<strong>size为0</strong></p><p>这就是扩容。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>目前为止，原则上我们的自制HashMap已经全部完成。 简单总结一下几个核心：</p><ul><li><strong>hash函数</strong>。<strong>解决key与下标相关联的问题</strong>。在这里，我们采用的是Object自身的hascode来和capacity进行取余来计算。hashcode可以基本保证一个独有的值，取余只是为了让hashcode可以放置在数组之中</li><li><strong>Node[]对象数组</strong>。<strong>解决如何存储的问题</strong>。在这里，我们底层采用的是对象<strong>数组</strong>，我们将KV封装为一个节点对象，这是为了KV的一体性</li><li><strong>Hash冲突</strong>。<strong>解决当两个key的hash值一样如何解决的问题</strong>。在这里，使用的是<strong>线性探测法</strong></li><li><strong>扩容。解决当capacity不够用的问题。</strong>扩容的核心是需要定义清楚size与capacity的含义</li></ul><p><strong>如下表1，是HashMap与MyHashMap的对标：</strong></p><table><thead><tr><th align="left"></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td align="left">HashMap</td><td><strong>39ms</strong></td><td><strong>11ms</strong></td></tr><tr><td align="left">MyHashMap -（数组+ 线性探测）</td><td><strong>1068ms</strong></td><td><strong>113ms</strong></td></tr></tbody></table><p>在这里，有一个小小的插曲，我在进行大容量测试的时候，出现了一个数组越界的异常，日志显示我有一个负数的下标。</p><p>？？？</p><p>经排查，hashcode是有可能为负数的，其根本原因是hashcode的算法要不停的相乘然后累加，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from JDK String.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的根本原因是因为，int的范围在-2^31 ~ 2^31 - 1 即[-2147483648, 2147483647]</p><p>截止到此，我们的整个的Map就开发完毕了。</p><p><strong>但，我们的put性能慢了26倍，get性能慢10倍</strong></p><h2 id="自制HashMap的性能追逐"><a href="#自制HashMap的性能追逐" class="headerlink" title="自制HashMap的性能追逐"></a>自制HashMap的性能追逐</h2><p>首先，可以进行改进的地点有哪些？</p><p>哈哈哈，当然是核心要点那里：hash函数、冲突方法、底层存储以及扩容结构</p><h3 id="hash函数的探索"><a href="#hash函数的探索" class="headerlink" title="hash函数的探索"></a><strong>hash函数的探索</strong></h3><p>先开始一些专业点的东西，什么叫做Hash函数</p><p><strong>定义</strong>：hash function 又称散列函数、哈希函数，指的是，将任意长度的数据映射到有限长度的域上。映射后的值称为哈希值。</p><p><strong>性质</strong>：</p><p>​        1. 如果两个哈希值不同，那么原始输入一定不同；但哈希值相同，原始输入不一定相同，这种情况称之为“哈希碰撞”。一个好的hash函数的设计很少出现哈希碰撞。</p><p>​        2. 哈希值就有不可逆性，没有办法用来逆向计算原来的数值。其根本原因在于性质1，同一个hash值对应的输入有很多。</p><p><strong>应用</strong>：保护资料，如SHA-256；确保传递真实的信息；散列表；错误校正，如冗余校验；语音识别，如MD5；</p><p>这里，我们采用Java 8中的Hash函数来进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个依旧借助了hashCode来计算hash值，即 h^(h&gt;&gt;&gt;16)</p><p>其中，&gt;&gt;&gt;  表示的是无符号右移，即，忽略符号为，空位都已0补齐。</p><p>举例，如10的二进制为1010，那么10 &gt;&gt;&gt; 2 指的是右移2位，即，0010 = 2 </p><p>之后，在使用的时候，需要进一步和当前capacity进行求 <strong>与</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (capacity - <span class="number">1</span>) &amp; hash(key);</span><br></pre></td></tr></table></figure><p>PS： 这里在测试get10万次的时候，才测试出来一个bug。当前的put的逻辑，先计算了hash值，再进行扩容，扩容之后整个hash函数已经打散了。但是，最终put到数组中的还是按照原来的Hash值去进行的。这样在进行get的时候，初始计算的Hash值不同，再进行进行线性探测的时候，轨迹完全不同，所以就会出现null的情况。</p><p>但令人痴迷的是，10万次仅有一次这种情况。</p><p>这次的比较结果，如表2所示：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>HashMap</td><td><strong>39ms</strong></td><td><strong>11ms</strong></td></tr><tr><td>MyHashMap -（数组+ 线性探测）</td><td><strong>1068ms</strong></td><td><strong>113ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + JDK8hash函数）</td><td><strong>25188ms</strong></td><td><strong>36445ms</strong></td></tr></tbody></table><p>怎么回事</p><p>我们明明改造了HashMap的hash函数，为什么性能更差呢？</p><p>这主要是因为我们的hash函数直接照抄jdk 却没有系统性的优化，比如，为什么hashCode要 右移16？我们这里的capacity=10，我们右移10是不是可以？</p><p>那么我们看看，这次的对比结果：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap -（数组+ 线性探测+右移10位+capacity=10）</td><td><strong>24936ms</strong></td><td><strong>24936ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=10）</td><td><strong>25188ms</strong></td><td><strong>36445ms</strong></td></tr></tbody></table><p>那，我们让capacity = 16呢？</p><p>神奇的事情发生了！！！！</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap -（数组+ 线性探测+右移10位+capacity=10）</td><td>24936ms</td><td>24936ms</td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=10）</td><td>25188ms</td><td>36445ms</td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移8位 + capacaity=8）</td><td><strong>935ms</strong></td><td><strong>116ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移16位 + capacaity=16）</td><td><strong>710ms</strong></td><td><strong>76ms</strong></td></tr><tr><td>MyHashMap - （数组 + 线性探测 + 右移32位 + capacaity=32）</td><td>41983ms</td><td>68684ms</td></tr><tr><td>MyHashMap -（数组+ 线性探测 + hashcode%capacity+ capacity=10）</td><td>1068ms</td><td>113ms</td></tr><tr><td>MyHashMap -（数组+ 线性探测 + hashcode%capacity+ capacity=16）</td><td>995ms</td><td>98ms</td></tr></tbody></table><p>从上述的对比，我们发现，适当的增加capacity能简单的提升性能，但单纯修改这个值，无济于事。</p><p><strong>当jdk的hash函数 配合 capacity = 16 可以极大的提升性能。</strong></p><p>这里的16，是一个非常有讲究的数据</p><p>好了，经过我们的借鉴，我们目前put性能慢了17倍，get性能慢了5倍</p><h3 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h3><p>我们当前使用的线性探测的方法，当冲突之后，效率及其低下。有没有其他更加优雅的冲突解决方法？</p><p>这里直接给一些解决方案的汇总，大致可以分为在散列表内解决的，称之为闭散列法，在散列表之外解决的，称之为开散列法，也称之为拉链法。</p><p>来了，我依旧借鉴 jdk 8的经典拉链法。</p><p>所谓拉链法，就是当hash冲突的时候，已当前的node节点为首位，不停往下扩展。所以，首先需要修改原始数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> V value;</span><br><span class="line">    <span class="keyword">private</span> Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，就是链表的结构</p><p>然后，当put和get的时候按照新的冲突方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (<span class="keyword">this</span>.capacity - <span class="number">1</span>) &amp; hash(key);</span><br><span class="line">    Node&lt;K,V&gt; p = table[hash];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        table[hash] = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p.next = <span class="keyword">new</span> Node&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = (<span class="keyword">this</span>.capacity - <span class="number">1</span>) &amp; hash(key);</span><br><span class="line">    Node&lt;K,V&gt; p = table[hash];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p.getKey().equals(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> p.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (p.getKey().equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造如此完美，而且，resize是不是不是必须的了？因为容量无穷无尽。当然了，经过接下来的测试，resize依旧需要，但他的作用变了。</p><p>第一波的测试：</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10)</td><td>989ms</td><td>106ms</td></tr><tr><td>MyHashMap2-(数组 + 线性探测 + 右移16位 + capacaity=16)</td><td>681ms</td><td>66ms</td></tr><tr><td><strong>MyHashMap3-(数组 + 拉链法(无resize)+ 右移16位 + capacaity=16)</strong></td><td><strong>14387ms</strong></td><td><strong>20365ms</strong></td></tr><tr><td>HashMap(JDK 8)</td><td>31ms</td><td>10ms</td></tr></tbody></table><p>原因很简单，没有resize啊，太臃肿了，导致算完hash都需要循环遍历，这有违初衷o(1)啊</p><p>这里提出一个新的概念，我们如何衡量Hash函数的性能？这里需要首先计算平均查找长度（ASL），而ASL又依赖于装载因子，</p><p><strong>装载因子 = 填入表中的元素个数 / Hash表的长度</strong></p><p>性质：当装载因子越大，说明元素个数多，空闲位置少，冲突概率大，ASL就越大，性能下降。</p><p>所以，真正的扩容，应该在达到一定的装载因子时就要进行.</p><p>这里不再证明，选择JDK 8的装载因子 <strong>0.75</strong> 我们分别进行测试</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子为1)</td><td>1083ms</td><td>107ms</td></tr><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子为0.75)</td><td><strong>234ms</strong></td><td><strong>135ms</strong></td></tr></tbody></table><p>天啊，，，仅仅是修改一个扩容的条件而已，性能居然好到令人发指</p><p>ok, 我们接下来进行一个 完整的测试，同时针对拉链法进行扩容改造</p><table><thead><tr><th></th><th>put 10万次</th><th>get 10万次</th></tr></thead><tbody><tr><td>MyHashMap1-(数组+ 线性探测+hashCode%capacity+capacity=10+装载因子0.75)</td><td>228ms</td><td>124ms</td></tr><tr><td>MyHashMap2-(数组 + 线性探测 + 右移16位 + capacaity=16++装载因子0.75)</td><td>124ms</td><td>15ms</td></tr><tr><td><strong>MyHashMap3-(数组 + 拉链法(有resize)+ 右移16位 + capacaity=16+装载因子0.75)</strong></td><td><strong>46ms</strong></td><td><strong>14ms</strong></td></tr><tr><td>HashMap(JDK 8)</td><td>31ms</td><td>10ms</td></tr></tbody></table><p>神奇的事情，终于发生了。</p><p>我们的性能追上来了</p><p><strong>我们的性能终于在10万量级追上了jdk1.8</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们对全文进行一个粗略的总结</p><ul><li>存储结构。<strong>底层是对象数组。</strong>对象用于标记KV对，数组用于将hash值与下标进行关联。</li><li>Hash函数。解决key与Hash值一一映射的关系。借助Object的HashCode进行计算，JDK 8采用 h^(h&gt;&gt;&gt;16)</li><li>初始容量。为了与Hash函数一致，初始容量为16。</li><li>装载因子。扩容有一个合适的时机，过早扩容，会因扩容影响性能；过晚扩容，则会增大Hash函数的冲突的概率，影响性能</li><li>Hash冲突。本文选择了拉链法与线性探测法，我们可以看到，在put的性能拉链法优于线性探测法，而get性能差距不大</li></ul><p>附录</p><ol><li>内部类的作用以及为什么需要静态内部类？</li><li>深拷贝与浅拷贝</li><li>hashCode与int的范围</li><li>jdk 1.8的初始容量与hash函数的设计</li><li>装载因子为0.75的数学含义</li><li>JDK 引入红黑树</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 徒手撸轮子系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次，上路</title>
      <link href="posts/origin.html"/>
      <url>posts/origin.html</url>
      
        <content type="html"><![CDATA[<h1 id="再一次，上路"><a href="#再一次，上路" class="headerlink" title="再一次，上路"></a>再一次，上路</h1><p>很早就想把自己的博客网站重新给搞起来，也不知道是真的没时间还是怎么的，一直拖到现在，也是因为很偶然的因素，想着推出一个自己的一个系列。</p><p>系列的内容就是，重复的造轮子，终极目的是能把所有的东西给造一遍。</p><p>呃。。。</p><p>你知道的，我开个玩笑。</p><p>类似的事情，我关注的亦或是我没关注的，有很多人在做了。我也没必要去对标，也没有特别的标新立异，甚至我还会参考、借鉴。毕竟，别人比我理论研究的更深、图解画的更详细、甚至于语言表达更好。</p><p>我自己只不过是经验尚浅的码农，在一点一点前进罢了。</p><p>废话不多说。</p><p>系列的名字就叫做——《徒手撸轮子系列》</p><p>大致分为几个部分：</p><ul><li>原生数据结构与算法对标，如：HashMap、Set、List、Sort、Thread等</li><li>基础框架，如：Spring、Spring Boot等</li><li>基础通信组件，如：Thrift、Netty等</li><li>基础存储设施，如：MySQL、Redis等</li><li>基础消息队列，如：Kafka等</li><li>……</li></ul><p>当然，我会逐步增加。</p><p>基本节奏大致会按照：背景 —&gt; 需求 —&gt; 自己开发 —&gt; 性能对比 —&gt; 源码解析—&gt; 八股分析 —&gt; 背诵要点总结</p><p>那么，就开始把。</p><p>2021年4月26日总第一期：<a href="https://yzhao.top/posts/myHashMap.html">&lt;&lt;徒手撸轮子系列之HashMap——我们撸一个HashMap怎么样&gt;&gt;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
